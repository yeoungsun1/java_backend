day08
git과 gitHub 복습 -> java 문법 -> 회원클래스(로그인/회원가입)

0. git과 gitHub 복습
1) 버전 관리 시스템
	git 분산 버전 관리 시스템
	파일의 변화 내용을 기록, 관리하고 추적을 도와주는 소프트웨어

2) git-hub
	git을 저장하고 공유할 수 있는 서버를 제공하는 사이트 중 하나
	git을 저장하면 다른 pc에서도 쉽게 버전을 관리할 수 있으며
	다른 사람들과 git을 공유하여 협업이 된다는 장점이 있다

3) git의 구조
- Working Directory(작업폴더, 깃의 작업 공간)
	설정하게 되면 해당 폴더 내에 .git 숨김 폴더가 생성된다

	명령어 : git init
	파일의 상태 : 아직 git의 관리 대상이 아니다
		관리 대상이 아닌 파일을 untracked 상태라고 한다

- Staging Area(스테이징 영역)
	스테이징 영역에 있는 파일들은 git의 관리 대상이다
	수정, 추가, 삭제 등 이 영역의 파일 변경사항을 git이 저장하고 관리한다
	수정사항을 바로 local repository에 커밋하면 실수가 많아지므로
	스테이징영역에서 우선 수정 내용들을 검토하고 확인 후 로컬 저장소에 커밋한다
	
	명령어 : git add 파일명 or git add .
	파일의 상태 : 관리 대상 파일이 되며 tracked(추적) 상태라고 한다
	
	tracked 상태의 종류
	unmodified : 수정이 되지 않은 상태
	modified : 수정이 된 상태
	staged : 로컬 저장소에 올릴 준비가 완료된 상태

- Local Repository(로컬저장소)
	스테이징 영역에서 staged 상태의 파일을 commit 하면 로컬 저장소에 저장된다(버전을 확정짓는다)
	내가 원할 때 언제든 저장한 버전으로(commit 한 시점) 돌아갈 수 있다
	※ 주의사항 : staged 상태가 아니라면 commit이 되지 않는다

	명령어 : git commit -m "커밋메시지"
	파일의 상태 : 버전을 확정 짓는다

- Remote Repository(원격저장소)
	원격 저장소에 로컬 저장소에서 확정한 버전을 올리기 위해서는 원격저장소에 작업공간을 만들어둬야한다
	원격 저장소와 로컬 저장소를 연결해줘야한다
	git remote -v 확인 시 
		origin url주소 (fetch)
		origin url주소 (push)
	2줄이 나오면 제대로 연결된 것이고 만약 아무것도 나오지 않는다면 url 주소를 연결해야한다
	git remote add origin url주소
	
	연결이 정상적으로 된 상태라면 로컬 저장소에 있는 내용을 원격 저장소로 올려줄 수 있고,
	원격 저장소에 있는 내용을 로컬 저장소로 내려 받을 수 있다.
	git push origin 브랜치명
		git push origin main
	git pull origin 브랜치명
		git pull origin main
	만약 이 때 오류가 발생한다면 
	rejected발생 시 hint 아래서 2번째 내용을 확인한다
		git pull origin main
	fatal 발생 시 unrelated histories 
		git pull origin main --allow-unrelated-histories
		원격 저장소의 커밋 기록과 로컬 저장소의 커밋 기록이 달라서 발생하는 오류기 때문에
		강제로 원격 저장소의 내용을 로컬 저장소로 내려받는다
		git log 확인 시 origin/main 원격저장소의 브랜치가 보이게된다
	git push origin main	이제 로컬저장소에 있는 작업 내용을 원격 저장소로 올려준다

4) git 명령어
[git-hub 설정 명령어]
git config --list
	설정 내용 확인하는 명령어
	user.name=내 github이름
	user.email=내 github 이메일주소
git config --global user.name "github이름"
git config --global user.email "github이메일주소"

[기본 명령어]
git init
	현재 위치의 폴더를 Working directory로 만드는 명령어
	.git 숨김폴더가 생성된다
	파일 탐색기 > 보기탭 > 확장자, 숨김폴더 반드시 체크
git status
	현재 깃 저장소에 있는 파일들의 상태 확인
git add 파일명 or git add .
	작업 폴더의 파일을 스테이징 시킨다
git commit -m "커밋메시지"
	스테이징 영역의 파일들의 변경사항을 확정 짓고 새로운 버전을 로컬 저장소에 저장한다
git log
	git에 저장된 commit 기록을 볼 수 있다
	가장 최근 commit부터 상단에 출력된다
git rm --cached 파일명
	add로 스테이징 시킨 파일을 스테이징 영역에서 내보내는 명령어(working directory 위치로 간다)
	add부터 해야하며 깃이 추적하는 상태가 아니게 된다

[브랜치와 관련된 명령어] => commit 기록이 하나라도 있어야 확인 가능하다
git branch
	현재 브랜치 목록 보기
git branch 새로운브랜치명
	새로운 브랜치 생성
git branch -m 기존브랜치명 변경할브랜치명
	브랜치명 수정
git branch -D 기존브랜치명
	브랜치 삭제
git switch 브랜치명
	브랜치 이동(현재 권장하는 방식)

[원격저장소와 관련된 명령어]
git remote -v
	원격저장소와 연결이 잘 되었는지 확인하는 명령어
	origin gitHub url주소 (fetch)
	origin gitHub url주소 (push)
git remote add [origin] [gitHub url 주소]
	원격 저장소를 내 로컬과 연경하는 명령어
git push [origin] [브랜치명]
	로컬저장소에 커밋한 파일을 원격 저장소에 올려주는 명령어
	git push origin main
git pull [origin] [브랜치명]
	원격 저장소에 저장한 파일들을 로컬저장소로 가져오는 명령어
git clone [origin] [저장할경로]
	원격 저장소에 있는 파일들을 복제하여 로컬 저장소로 가져오는 명령어
	※ 주의사항!! 클론할 때는 절대 git init하지 않는다!!
	git init은 내 로컬에서 .git 폴더를 생성해서 처음부터 관리하는 것이고
	git clone은 다른 사람이 관리하던 log 내용까지 전부 복제해오는 것이다

1. java 문법
1) 변수
	값을 저장할 수 있는 저장공간
	- 재사용하기 위해 사용한다

	자료형 변수명 = 값;
	
2) 자료형(Data Type)
	타입	크기	예시
정수형	int	4byte	0, -100, 350, ..
	long	8byte	0L, -100L, 11111L, ...
실수형	double	8byte	0.0, 256.12, -3.141592, ...
	float 	4byte	0.0f, 2.4f, -3.14f, ..
논리형	boolean 1byte	true, false
문자형	char	2byte	유니코드 기반 	' '로 묶어진 1개의 문자
문자열	String 	?	""로 묶어진 0개 이상의 문자

3) 연산자 우선순위
	최우선연산자	가장 먼저 계산
			() 	.	[]
	단항연산자		피연산자가 1개
			++, -- 	!	+, -(부호)
	산술연산자		연산
			+	-	*	/	%
	쉬프트연산자	비트이동 연산자(보통 2진수로 계산시 사용)
			<<	>>
	관계연산자		크기 비교 시 사용되며 조건식
			관계 연산자의 결과는 항상 boolean 타입
			>	<	>=	<=	==	!=
	논리연산자		조건 연결 시 사용
			&& 	||	!
	삼항연산자		피연산자가 3개
			조건에 따라 값을 선택할 때 사용(간단한 조건식일 경우)
			조건식 ? 참 일 때의 값 : 거짓일 때의 값;
	대입연산자		변수 등에 값 저장 시 사용
			가장 마지막에 실행된다

4) 제어문(Control Statement)
	프로그램의 실행흐름을 제어하기 위해 사용한다
	조건문, 반복문, 기타제어문

(1) 조건문
	조건에 따라 실행할 문장을 선택할 때 사용한다
- if ~ else if ~ else문 : 조건이 2개 이상일 때 사용, 위에서부터 조건을 검사하며 true가 제일 먼저 나오는 하나만 실행
	if(조건식1) {
		조건식1의 결과가 참일 때 실행될 문장;
	}else if(조건식2) {
		조건식1이 거짓이고 조건식2가 참일 때 실행될 문장;
	}else if(조건식3) {
		조건식 1과 2가 거짓이고 조건식3이 참일 때 실행될 문장;
	}...{
	} else{
		조건식 1, 2, 3이 모두 거짓일 때 실행될 문장;
	}

- switch문 : 값을 비교하여 분기 처리, 경우의 수가 명확할 때 주로 사용
	switch(변수){
	case 값1:
		실행문1;
		break;	//case마다 break문을 반드시 써야한다!
	case 값2:
		실행문2;
		break;
	...
	defualt:	//모든 case에 해당하지 않을 때 실행
		실행문;
		break;
	}

(2) 반복문 : 같은 코드를 여러번 반복해서 실행하고 싶을 때 사용

- for문 : 횟수나 범위가 정해져있을때 사용
	for(초기식; 조건식; 증감식){
		//반복 실행할 문장;
	}

	초기식
	조건식의 결과가 true면 
	실행문
	증감식
	조건식을 확인 -> 조건식의 결과가 true면
	실행문
	증감식
	조건식을 확인 -> 조건식의 결과가 false면
	반복문 탈출
	for(int i = 0; i < 3; i++){
		syso(i);
	}

첫번째반복 초기식	i의 값은 0
	조건식	i < 3	=> 0 < 3 true
	실행문	0 출력
두번째반복	증감식	i++	=> 0 + 1 	현재 i의 값은 1
	조건식	i < 3 	=> 1 < 3 true
	실행문	1 출력
세번째반복	증감식 	i++	=> 1 + 1	현재 i의 값은 2
	조건식	i < 3 	=> 2 < 3 ture
	실행문	2 출력
네번째반복	증감식	i++	=> 2 + 1	현재 i의 값은 3
	조건식	i < 3 	=> 3 < 3 false
	반복문 탈출
	
- while문 : 횟수나 범위가 불명확할 때 사용
	while(조건식){
		실행문;
	}
	조건비교대상이 될 변수를 먼저 선언해야한다
	조건비교대상이 될 변수의 값이 변화해야한다

- do~while문 : 무조건 1번 실행해야할 때 사용
	do {
		실행문;
	}while(조건식);

	실행문이 1번 실행 후 조건식을 확인하여 true면 다시 실행문이 실행되고 
	조건식이 false면 do~while문을 탈출하게 된다

(3) 기타제어문
- break문
	반복문 즉시 종료, switch문에서 case 끝날때마다 사용
- continue문
	현재 반복 건너뛰기

5) 메소드(Method)
	기능(동작)을 담당하는 코드 묶음

(1) 메소드 구조
	반환타입 메소드명(자료형 매개변수){
		실행문;
		return 값;
	}

(2) 메소드 사용 이유
	코드 재사용
	가독성 향상
	유지보수 쉬움

(3) 메소드 호출(4가지)
	매개변수	리턴값(반환값)	메소드 호출
	x	x		객체명.메소드명();
	o	x		객체명.메소드명(인수);
	x	o		syso(객체명.메소드명());
				자료형 변수 = 객체명.메소드명();
	o	o		syso(객체명.메소드명(인수));
				자료형 변수 = 객체명.메소드명(인수);

(4) 메소드 정의와 사용
	메소드를 정의할 때는 메소드 중괄호 영역 밖에서 정의하고
	메소드를 사용할 때는 메소드 중괄호 영역 안에서 사용한다

6) 클래스(Class)
	객체를 만들기 위한 설계도

(1) 클래스 구성
	필드
	생성자
	메소드

(2) 사람 클래스
	class Person{
		//필드
		String name;
		int age;

		//생성자
		Person(String name, int age){
			this.name = name;
			this.age = age;
		}

		//메소드	
		void info(){
			syso(this.name + "은/는 " + this.age + "살입니다."); 
		}

	}

(3) 객체 생성
생성자가 없을 때 객체 생성 방법 : 기본 생성자가 자동으로 만들어지며 객체 생성 후에 필드에 직접 값을 대입
	Person p1 = new Person();
	p1.name = "홍길동";
	p1.age = 20;
	p1.info();

생성자가 있을 때 객체 생성 방법 : 기본 생성자는 자동으로 생성되지 않으며 객체 생성 시 반드시 생성자에 맞게 값 전달
	Person p2 = new Person("홍길동", 10);
	p1.info();

(4) 생성자 특징
	클래스 이름과 동일
	반환타입이 없음(void도 X)
	객체 생성시 자동 호출
	주로 필드 초기화에 사용

(5) this 키워드
	현재 객체를 의미(객체 자기자신을 의미함)
	필드와 매개변수의 이름이 같을 때 구분

+) 생성자는 객체 생성 시 자동으로 호출되며, 필드 초기화를 담당한다
생성자가 있으면 객체 생성 시 반드시 해당 생성자를 사용해야한다

7) 접근 제한자
접근제한자		같은클래스내	같은패키지		다른패키지(상속)		다른패키지(일반)
public		o		o		o			o
protected	o		o		o			x
(default)	o		o		x			x
private		o		x		x			x
※  private이 붙은 필드는 같은 클래스에서 가능하며, 같은 패키지나 다른 패키지에서 사용시에는 getter, setter 메소드로만 접근 가능

8) ArrayList
	크기가 자동으로 늘어나는 배열

(1) ArrayList 선언
	ArrayList<제네릭> 객체명 = new ArrayList<>();
	기본형 사용 불가능 -> Wrapper 클래스 사용
	int	-> Integer
	double	-> Double
	...

(2) 주요 특징
	순서가 있다
	중복을 허용한다
	크기가 자동증가한다

(3) 주요 메소드
- 데이터 추가
	.add(값);
- 데이터 조회
	.get(인덱스);
- 크기 확인
	.size();
- 삭제
	.remove(인덱스);
- 수정
	.set(인덱스, 값);

(4) 반복문
	ArrayList<Integer> list = new ArrayList<>();
	list.add(1);
	list.add(2);
	list.add(3);
	list.add(4);
	list.add(5);
	syso(list);	[1, 2, 3, 4, 5]

+) ArrayList + 일반 for문
	인덱스 사용가능, 수정/삭제 시 제어하기 쉬움

	for(int i = 0; i < list.size(); i++){
		syso(list.get(i));
	}
	출력결과
	1
	2
	3
	4
	5

+) ArrayList + 향상된 for문(for-each문)
	코드 간결, 인덱스 접근 불가능, 값 변경/삭제 불가능

	for(int num : list){
		syso(num);
	}
	
	출력결과
	1
	2
	3
	4
	5











